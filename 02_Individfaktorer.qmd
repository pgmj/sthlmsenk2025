---
title: "Individfaktorer"
title-block-banner: "#009ca6"
title-block-banner-color: "#FFFFFF"
date: last-modified
format: html
execute:
  echo: true
  warning: false
  message: false
  cache: true
editor_options: 
  markdown: 
    wrap: 72
  chunk_output_type: console
---

```{r}
#| label: setup
#| include: false

library(mokken)
library(arrow)
library(ggrepel)
library(car)
library(grateful) 
library(kableExtra)
library(readxl)
library(tidyverse)
library(eRm)
library(mirt)
library(iarm)
library(psych)
library(ggplot2)
library(psychotree)
library(matrixStats)
library(reshape)
library(knitr)
library(patchwork)
library(formattable) 
library(easyRasch) # devtools::install_github("pgmj/easyRasch")
library(glue)
library(foreach)
#library(foreign)
library(haven)
library(labelled)


### some commands exist in multiple packages, here we define preferred ones that are frequently used
select <- dplyr::select
count <- dplyr::count
recode <- car::recode
rename <- dplyr::rename
filter <- dplyr::filter

# import item information
itemlabels <- read_excel("itemlabels/IF_itemlabels.xls")

# where is the data? This is for Mac
datafolder <- "~/Library/CloudStorage/OneDrive-SharedLibraries-RISE/SHIC - Data i Dialog - Data i Dialog/data/"
df.all <- read_parquet(paste0(datafolder,"Stockholm Stad/2024/sthlm02-24.parquet"))

# add windows path below
#datafolder <- "C:/Users/fridasan/RISE/SHIC - Data i Dialog - 2024/"
#df.all <- read_parquet(paste0(datafolder,"sthlm02-24.parquet"))

#sthlm <- read_spss(paste0(datafolder,"Stockholm Stad/2024/Stockholmsenkäten 2002-2024 Stockholm.sav"))
#write_parquet(sthlm, paste0(datafolder,"Stockholm Stad/2024/sthlm02-24.parquet"))

# subset data for this analysis
df <- df.all %>% 
  select(itemlabels$itemnr,Kön,ARSKURS,ar,SkolSDO)

```

```{r}
#| label: recoderawdata
#| include: false

# ###### Individfaktorer
# # koda om svaren för items som ingår i individfaktorer, F66a-F66u i data, fråga 67 i PDF
# # variabler df[191:211]
# # hög poäng = hög risk
# # definiera svarskategorierna för att förenkla recode-koden
smd <- "Stämmer mycket dåligt"
sgd <- "Stämmer ganska dåligt"
sgb <- "Stämmer ganska bra"
smb <- "Stämmer mycket bra"

### New recode code below, using variable names instead of numbering

positiva.items <- c("f66h", "f66m", "f66p", "f66u") # create vector with reverse scored items
df.if <- df %>%
  slice(1:10) %>% 
  select(any_of(itemlabels$itemnr))
negativa.items <- df.if %>% # vector with items that are not reversed
  select(!any_of(positiva.items)) %>%
  names()

df_recoded <- df %>% 
  mutate(across(f66a:f66u, ~ as.numeric(.x))) %>% 
  mutate(across(all_of(negativa.items), ~ .x - 1),
         across(all_of(positiva.items), ~ car::recode(.x,"4=0;3=1;2=2;1=3")))

```

Check labels for demographic variables.

```{r}
val_labels(df_recoded$Kön)
val_labels(df_recoded$ARSKURS)
val_labels(df_recoded$SkolSDO)
```

Recode 99 and 999 to NA and make demographic variables to factors.

```{r}
df_r2 <- df_recoded %>% 
  mutate(SkolSDO = factor(SkolSDO, levels = val_labels(df_recoded$SkolSDO),
                          labels = names(val_labels(df_recoded$SkolSDO)))) %>% 
  mutate(Årskurs = factor(ARSKURS, levels = val_labels(df_recoded$ARSKURS),
                          labels = names(val_labels(df_recoded$ARSKURS)))) %>% 
  select(!ARSKURS) %>% 
  mutate(SkolSDO = car::recode(SkolSDO,"99=NA;'Övrigt ospecificerat'=NA"),
         Årskurs = car::recode(Årskurs,"999=NA")) %>% 
  mutate(Kön = factor(Kön, levels = 1:2, labels = c("Pojke","Flicka")),
         År = as.numeric(ar)) %>% 
  select(!ar)
```

```{r}
df_r2 %>% 
  select(f66a:f66u) %>% 
  pivot_longer(everything()) %>% 
  distinct(value)
```

Recoding looks good, no unexpected values remain.

```{r}
library(rsample)
set.seed(14578)
# create dataframe with 2024 data with all variables (post recode) and only complete responses
df24 <- df_r2 %>% 
  filter(År == 2024) %>% 
  na.omit() %>% 
  select(!År)

# Put 1/5 of the data into the training set 
data_split <- initial_split(df24, prop = 1/5, strata = SkolSDO)

# Create data frames for the two sets:
d <- training(data_split)
d_test  <- testing(data_split)

# create DIF df
d_dif <- d %>% 
  select(Kön,Årskurs,SkolSDO)

d_testdif <- d_test %>% 
  select(Kön,Årskurs,SkolSDO)

# remove non-items
d <- d %>% 
  select(!c(Kön,Årskurs,SkolSDO))
d_test <- d_test %>% 
  select(!c(Kön,Årskurs,SkolSDO))
```



## Frågor i enkäten

Item/frågor har etiketter f66a-f66u i datafilen, och motsvaras av fråga 67 i PDF-filen med frågor.

"Hur väl stämmer följande påståenden in på dig som person?" följs av de ingående frågorna, alla med samma fyra svarskategorier:

* 'Stämmer mycket dåligt'
* 'Stämmer ganska dåligt'
* 'Stämmer ganska bra'
* 'Stämmer mycket bra'

Svarskategorierna ersätts med siffror från 0 till 3, och för f66h, m, p och u är siffrorna omvända/reverserade, d.v.s. att "Stämmer mycket bra" kodas som "0" i stället för "3" till analysen. Det innebär att höga poäng genomgående innebär hög risk.

```{r}
#RIcolorlistitems(c(8,13,16,21), RISEprimGreenMid)
reverserade <- c(8,13,16,21)
itemlabels %>% 
  kbl(booktabs = T, escape = F) %>%
      # bootstrap options are for HTML output
      kable_styling(bootstrap_options = c("striped", "hover"), 
                    position = "left",
                    full_width = F,
                    font_size = 14,
                    fixed_thead = T) %>% # when there is a long list in the table
      row_spec(reverserade, bold = F, color = "white", background = "darkblue") %>% 
      column_spec(1, bold = T) %>% 
      kable_classic(html_font = "Lato")
```

## Deskriptiva data

### Demografi

```{r}
#| label: descriptives1
#| layout-ncol: 2
RIdemographics(d_dif$Kön, "Kön")
RIdemographics(d_dif$Årskurs, "Årskurs")
RIdemographics(d_testdif$SkolSDO, "SkolSDO")
```

### Item-data

::: panel-tabset
#### Tile plot
```{r}
RItileplot(d)
```
#### Stacked bars
```{r}
RIbarstack(d)
```
:::

## Analys 1 samtliga items

```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(d)
```

::: panel-tabset
### Mokken dimensionality
```{r}
aisp(d_test) %>% 
  as.data.frame() %>% 
  set_names("h > 0.3") %>% 
  arrange(`h > 0.3`) %>% 
  kbl_rise(tbl_width = 20)
```

### Item-restscore
```{r}
d_test %>% 
  #select(!any_of(removed_items)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(d)
```
### PCA
```{r}
#| tbl-cap: "PCA of Rasch model residuals"
RIpcmPCA(d_test)
#simpca <- RIbootPCA(d_test, iterations = 300, cpu = 8)
#simpca$p99
```
### Loadings 1st contrast
```{r}
#| label: fig-loadloc
RIloadLoc(d_test)
```
### Lokalt oberoende
```{r}
RIpartgamLD(d_test)
```
### Targeting
```{r}
#| fig-height: 9
RItargeting(d_test)
```
### Itemhierarki
```{r}
#| fig-height: 9
RIitemHierarchy(d_test)
```
### Svarskategorier
```{r}
mirt(d_test, model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-5,5))
```
### DIF kön
```{r}
RIpartgamDIF(d_test, d_testdif$Kön)
RIdifTableLR(d_test, d_testdif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(d_test, d_testdif$Årskurs)
RIdifTableLR(d_test, d_testdif$Årskurs)
```
:::

Vi har många items och tydliga tecken på multidimensionalitet:

- Mokken-analysen indikerar 3 dimensioner och flaggar 2 items (f66h och m) som undermåliga. Det framkommer en dominant dimension som innehåller 15/21 items.
  - Övriga avvikande items är f66l och s, samt f66p och u.
- PCA av residualer uppvisar tre eigenvalues över 1.5.
- Figuren med faktorladdningar på första residualkontrasten (@fig-loadloc) indikerar att f66h avviker mest, följd av m, p och u. Sedan ligger f66l och s lite närmare övriga items.
- Item-restscore bootstrap indikerar 100% underfit för f66h, l, m, p, och u, men ej f66s.

Items f66m, p, u, och l, är de items som jämfört med övriga är "reverserade", alltså de med ett positivt formulerat innehåll.

Flera items indikerar också DIF för kön (bl.a. f66l), men vi avvaktar med att agera specifikt på detta. Vi har också flera kraftiga lokala beroenden mellan items, men de är främst relaterade till multidimensionaliteten och även här avvaktar vi med specifika åtgärder kopplat till detta.

Vi tar bort dessa fem items:

```{r}
removed_items <- c("f66h","f66m","f66l","f66p","f66u")
itemlabels %>% 
  filter(itemnr %in% removed_items) %>% 
  kbl_rise()
```


## Analys 2 samtliga items

Utan items f66h m p u samt l.

```{r}
d_backup <- d

d <- d %>% 
  select(!any_of(removed_items))
```

```{r}
#| column: margin
#| echo: false

RIlistItemsMargin(d)
```

::: panel-tabset
### Mokken dimensionality
```{r}
aisp(d) %>% 
  as.data.frame() %>% 
  set_names("h > 0.3") %>% 
  arrange(`h > 0.3`) %>% 
  kbl_rise(tbl_width = 20)
```

### Item-restscore
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(d)
```
### PCA
```{r}
#| tbl-cap: "PCA of Rasch model residuals"
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIpcmPCA()
```
### Loadings 1st contrast
```{r}
#| label: fig-loadloc2
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIloadLoc()
```
### Lokalt oberoende
```{r}
#| label: tbl-ld2
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIpartgamLD()
```

### Residual correlations
```{r}
simcor <- d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIgetResidCor(cpu = 8)

d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIresidcorr(simcor$p99)
```

### Targeting
```{r}
#| fig-height: 9
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RItargeting()
```
### Itemhierarki
```{r}
#| fig-height: 9
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIitemHierarchy()
```
### Svarskategorier
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-5,5))
```
### DIF kön
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIpartgamDIF(d_testdif$Kön)
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIdifTableLR(d_testdif$Kön)
```
### DIF årskurs
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIpartgamDIF(d_testdif$Årskurs)
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIdifTableLR(d_testdif$Årskurs)
```
:::

Mokken indikerar item f66s som undermåligt. Item-restscore bootstrap likaså. Den senare flaggar även upp items f och k som med hög sannolikhet underfit, samt i mindre grad j. @fig-loadloc2 visar items f och j som mest avvikande.

Flera items är för lika varandra, vilket framkommer i @tbl-ld2. Starkaste sambanden finns mellan items e och t, samt e och c, följt av c och t. Dessa tre items är:

- c: Jag tål inte att bli provocerad, då kan jag slå till någon.
- e: Om jag blir arg på någon drar jag mig inte för att skada honom/henne.
- t: Den som gör mig arg ger jag mig på, även om han/hon inte slagit mig först.

Väldigt lika innehåll. Item e är mest avvikande i item-restscore, så vi tar bort den först. 

Items f66s och möjligen t (enbart partial gamma) uppvisar DIF för kön.

Inga items har oordnade trösklar mellan svarskategorierna.

Vi tar bort dessa items:

```{r}
itemlabels %>% 
  filter(itemnr %in% c("f66s","f66f","f66k","f66j","f66e")) %>% 
  kbl_rise()
```

## Analys 3 samtliga items

Utan items f66s f j k e.

```{r}
d_backup2 <- d
removed_items <- c(removed_items,"f66s","f66f","f66k","f66j","f66e")
d <- d %>% 
  select(!any_of(removed_items))
```

```{r}
#| column: margin
#| echo: false

RIlistItemsMargin(d)
```

::: panel-tabset
### Mokken dimensionality
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  aisp() %>% 
  as.data.frame() %>% 
  set_names("h > 0.3") %>% 
  arrange(`h > 0.3`) %>% 
  kbl_rise(tbl_width = 20)
```

### Item-restscore
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(d)
```
### PCA
```{r}
#| tbl-cap: "PCA of Rasch model residuals"
RIpcmPCA(d)
#RIbootPCA(d, iterations = 300, cpu = 8)
```

PCA simulations indicate max eigenvalue of 1.24 using the small sample.

### Loadings 1st contrast
```{r}
#| label: fig-loadloc3
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIloadLoc()
```
### Lokalt oberoende
```{r}
#| label: tbl-ld3
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIpartgamLD()
```
### Targeting
```{r}
#| fig-height: 7
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RItargeting()
```
### Itemhierarki
```{r}
#| fig-height: 7

d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIitemHierarchy()
```
### DIF kön
```{r}
RIpartgamDIF(d, d_dif$Kön)
RIdifTableLR(d, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(d, d_dif$Årskurs)
RIdifTableLR(d, d_dif$Årskurs)
```
### DIF skolområde
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIdifTable(d_testdif$SkolSDO)
```
:::

Svag DIF för skolområde gällande item f66c mellan område nod 5 och 8. Sammantaget med att det är ett för litet sampel för Skärholmen (nod 5) kan vi bortse från detta.

Lokala beroenden mellan items (@tbl-ld3) indikerar fortfarande problem mellan item c och t, och c har klart bättre targeting och ingen overfit enligt item-restscore. Även b och n flaggas upp, och b och g. Utifrån item-restscore är b och g ungefär lika overfit, men eftersom b har två problematiska samband bör den tas bort.

Items r och i är båda underfit, och i visar tendenser till DIF

- i: Jag ser mig själv som en ganska impulsiv person.
- r: Det händer att jag gör saker utan att tänka mig för.

Vi provar att enbart ta bort de items som är underfit och ser hur det påverkar item-restscore och lokalt beroende mellan items.

```{r}
d %>% 
  select(!c(f66i,f66r)) %>% 
  RIbootRestscore()

d %>% 
  select(!c(f66i,f66r)) %>% 
  RIpartgamLD()
```

Det är inga kvarvarande problem med item-restscore utan items i och r. Men problemen sinsemellan items kvarstår. Vi tittar på detta utifrån residualkorrelationer:

```{r}
#| label: tbl-rescor1
simcor1 <- d %>% 
  select(!c(f66i,f66r)) %>% 
  RIgetResidCor(iterations = 200, cpu = 8)

d %>% 
  select(!c(f66i,f66r)) %>% 
  RIresidcorr(cutoff = simcor1$p99)
```

@tbl-rescor1 bekräftar bilden av att item f66b orsakar problem med g och n, samt att c och t är för lika.

```{r}
d %>% 
  select(!c(f66i,f66r)) %>% 
  RItargeting()
```

- c: Jag tål inte att bli provocerad, då kan jag slå till någon.
- t: Den som gör mig arg ger jag mig på, även om han/hon inte slagit mig först.

Item t har sämre targeting och uppvisar viss DIF för kön. Vi tar bort b och t.

## Analys 4 samtliga items

Utan items f66r i b och t.

```{r}
d_backup3 <- d
removed_items <- c(removed_items,"f66r","f66i","f66b","f66t")
d <- d %>% 
  select(!any_of(removed_items))
```

```{r}
#| column: margin
#| echo: false

RIlistItemsMargin(d)
```

::: panel-tabset
### Item-restscore
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(d)
```
### Loadings 1st contrast
```{r}
#| label: fig-loadloc4
RIloadLoc(d)
```
### Lokalt oberoende
```{r}
#| label: tbl-ld4
RIpartgamLD(d)
```
### Residualkorrelationer
```{r}
#| label: tbl-rescor4
simcor2 <- RIgetResidCor(d, iterations = 250, cpu = 8)

RIresidcorr(d, cutoff = simcor2$p99)
```
### Targeting
```{r}
#| fig-height: 5
RItargeting(d)
```
### Itemhierarki
```{r}
#| fig-height: 5
RIitemHierarchy(d)
```
:::

Items g och n uppvisar en residualkorrelation klart över det simuleringsbaserade gränsvärdet, och indikeras även av partial gamma-analysen (denna problematik fanns även tidigare, och inkluderade item b). Item n har lite bättre targeting och lägre grad av misfit i item-restscore.

- g: Jag struntar i regler som hindrar mig från att göra det jag vill göra.
- n: Jag gör dumma saker även om de är lite farliga.

Dock kan det argumenteras för att g är innehållsmässigt mera relevant för normbrytande.

## Analys 5 samtliga items

Utan item f66n.

```{r}
d_backup4 <- d
removed_items <- c(removed_items,"f66n")
d <- d %>% 
  select(!any_of(removed_items))
```

```{r}
#| column: margin
#| echo: false

RIlistItemsMargin(d)
```

::: panel-tabset
### Conditional infit
```{r}
simfit1 <- RIgetfit(d, iterations = 200, cpu = 8)
RIitemfit(d, simfit1)
```
### Item-restscore
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(d)
```
### Lokalt oberoende
```{r}
#| label: tbl-ld5
RIpartgamLD(d)
```
### Residualkorrelationer
```{r}
#| label: tbl-rescor5
simcor5 <- RIgetResidCor(d, iterations = 250, cpu = 8)

RIresidcorr(d, cutoff = simcor5$p99)
```
### Targeting
```{r}
#| fig-height: 5
RItargeting(d)
```
### Itemhierarki
```{r}
#| fig-height: 5
RIitemHierarchy(d)
```
### Conditional LRT
```{r}
clr_tests(d, model = "PCM")
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIbootLRT(samplesize = 400, cpu = 8)
```
### PCA residuals
```{r}
RIpcmPCA(d)
RIbootPCA(d, iterations = 300, cpu = 8)
```
### DIF kön
```{r}
RIpartgamDIF(d, d_dif$Kön)
RIdifTableLR(d, d_dif$Kön)
RIdifThreshFigLR(d, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(d, d_dif$Årskurs)
RIdifTableLR(d, d_dif$Årskurs)
RIdifThreshFigLR(d, d_dif$Årskurs)
```
### DIF kön/årskurs
```{r}
#| fig-height: 3
RIdifTable2(d, d_dif$Kön, d_dif$Årskurs)
```
:::

Det finns två residualkorrelationer som indikeras (a och o, samt d och g), men sammanvägt med partial gamma LD som endast indikerar d och g precis över gränsvärdet 0.21 förefaller det försumbart? Svag DIF för kön för item f66o enligt partial gamma. Ingen DIF-interaktion mellan kön och årskurs.

LRT indikerar dock, även med bootstrap med lägre sampelstorlek, att vi fortfarande har smärre problem.

```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  select(!f66c) %>% 
  RIbootLRT(samplesize = 400)

d_test %>% 
  select(!any_of(removed_items)) %>% 
  select(!f66o) %>% 
  RIbootLRT(samplesize = 400)

d %>% 
  select(!f66c) %>%
  RIrestscore()

d %>% 
  select(!f66o) %>% 
  RIrestscore()
```

Det verkar vara f66o som främst ställer till detta, men itemet är overfit, så det kanske är acceptabelt.

```{r}
d %>% 
  as.data.frame() %>% 
  iarm::ICCplot(itemnumber = c(1:4),
                itemdescrip = names(d)[1:4],
                method = "cut")

d %>% 
  as.data.frame() %>% 
  iarm::ICCplot(itemnumber = c(5:6),
                itemdescrip = names(d)[5:6],
                method = "cut")
```

Grupp-residualerna ovan ligger nära linjen, men det finns en del ojämnheter. f66o ligger något lågt för de lägre klassintervallen, medan q hamnar lågt för den högsta gruppen

```{r}
#| layout-ncol: 2
library(RASCHplot)
CICCplot(PCM(d), which.item = 1:4, lower.groups = c(5,8,11,14))
CICCplot(PCM(d), which.item = 5:6, lower.groups = c(5,8,11,14))
```

Konfidensintervallen är stora för flera grupperingar. Vi provar med det större samplet.

```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  PCM() %>% 
  CICCplot(which.item = 1:4, lower.groups = c(5,8,11,14))

d_test %>% 
  select(!any_of(removed_items)) %>% 
  PCM() %>% 
  CICCplot(which.item = 5:6, lower.groups = c(5,8,11,14))
```

Smärre avvikelser.

### Reliabilitet

```{r}
#| fig-height: 4

d_test %>% 
  select(!any_of(removed_items)) %>% 
  RItif(samplePSI = T)
```

### Item-parametrar

```{r}
itemlabels %>% 
  filter(itemnr %in% names(d)) %>% 
  write_csv("results/IF_itemnr.csv")

d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIitemparams()

d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIitemparams(output = "file", filename = "results/IF_itemparams.csv")
```

### Targeting

```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RItargeting()
```

### Person fit

```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIpfit()
```

### Summerande kommentar

Vi har en påtaglig golveffekt eftersom majoriteten av elever inte uppvisar denna typ av beteenden i någon större utsträckning. Person fit är ok.

Reliabiliteten är inte strålande, och p.g.a. targeting-problemen främst relevanta för att särskilja bland elever som har mera problem.

```{r}
thetas <- d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIestThetas()

thetas %>% 
  mutate(gränsvärde = ifelse(WLE < 0.5, "under 0.5","över 0.5")) %>% 
  count(gränsvärde) %>% 
  mutate(Percent = round(n*100/sum(n),1)) 
```

Vi förväntar oss inte stora mängder elever som har problematiska nivåer av normbrytande beteenden, så det förefaller rimligt att denna skala är ändamålsenlig för att identifiera elever med problem och även följa förändring hos dessa elever.


### Transformeringstabell
```{r}
d_test %>% 
  select(!any_of(removed_items)) %>% 
  RIscoreSE()
```

### DIF över årtal

::: panel-tabset
#### Data prep
```{r}
df_r2 %>% 
  select(f66a,f66c,f66d,f66g,f66o,f66q,År) %>% 
  count(År)

difdata <- df_r2 %>% 
  select(f66a,f66c,f66d,f66g,f66o,f66q,År) %>% 
  filter(År > 2012) %>% 
  na.omit()

difdata %>% 
  count(År)

dif_år <- difdata$År
difdata$År <- NULL
```

#### DIF tabell
```{r}
RIdifTable(difdata,dif_år)
```
#### DIF figur
```{r}
RIdifFigure(difdata,dif_år) +
  scale_y_continuous(limits = c(-2,2))
```
:::

Bra stabilitet i item-trösklar över mätningarna från 2016 till 2024.

## Analys 1 positiva items

```{r}
items.pos <- c("f66h","f66l","f66m","f66p","f66s","f66u")

d <- d_backup %>% 
  select(any_of(items.pos))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(d)
```

::: panel-tabset
### Mokken dimensionality
```{r}
aisp(d) %>% 
  as.data.frame() %>% 
  set_names("h > 0.3") %>% 
  arrange(`h > 0.3`) %>% 
  kbl_rise(tbl_width = 20)
```

### Item-restscore
```{r}
d_test %>% 
  select(any_of(items.pos)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(d)
```
### PCA
```{r}
#| tbl-cap: "PCA of Rasch model residuals"
RIpcmPCA(d)
```
### Loadings 1st contrast
```{r}
RIloadLoc(d)
```
### Lokalt oberoende
```{r}
RIpartgamLD(d)
scor_pos <- RIgetResidCor(d, iterations = 250, cpu = 8)
RIresidcorr(d,cutoff = scor_pos$p99)
```
### Targeting
```{r}
#| fig-height: 9
RItargeting(d)
```
### Itemhierarki
```{r}
#| fig-height: 9
RIitemHierarchy(d)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(items.pos)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,4))
```
### DIF kön
```{r}
RIpartgamDIF(d, d_dif$Kön)
RIdifTableLR(d, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(d, d_dif$Årskurs)
RIdifTableLR(d, d_dif$Årskurs)
```
:::

Flera items har mycket små avstånd för nästa högsta svarskategorin jämfört med de intilliggande. Det gäller främst item p, u och m, men även h.

Items l och s är för lika varandra. Item l uppvisar svag DIF, och som item2 i partial gamma är den mera problematisk än som item1.

```{r}
RIbootLRT(d %>% select(!f66l), iterations = 1000, cpu = 8)
RIbootLRT(d %>% select(!f66s), iterations = 1000, cpu = 8)
```

Även LRT styrker detta, så vi tar bort item l.


## Analys 2 positiva items

```{r}
dpos_backup <- d

removed_items_pos <- "f66l"

d <- d %>% 
  select(!any_of(removed_items_pos))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(d)
```

::: panel-tabset
### Mokken dimensionality
```{r}
aisp(d) %>% 
  as.data.frame() %>% 
  set_names("h > 0.3") %>% 
  arrange(`h > 0.3`) %>% 
  kbl_rise(tbl_width = 20)
```

### Item-restscore
```{r}
d_test %>% 
  select(any_of(items.pos)) %>% 
  select(!any_of(removed_items_pos)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(d)
```
### PCA
```{r}
#| tbl-cap: "PCA of Rasch model residuals"
RIpcmPCA(d)
```
### Loadings 1st contrast
```{r}
RIloadLoc(d)
```
### Lokalt oberoende
```{r}
RIpartgamLD(d)
scor_pos2 <- RIgetResidCor(d, iterations = 250, cpu = 8)
RIresidcorr(d, cutoff = scor_pos2$p99)
```
### Targeting
```{r}
#| fig-height: 9
RItargeting(d)
```
### Itemhierarki
```{r}
#| fig-height: 9
RIitemHierarchy(d)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(items.pos)) %>% 
  select(!any_of(removed_items_pos)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,4))
```
### DIF kön
```{r}
RIpartgamDIF(d, d_dif$Kön)
RIdifTableLR(d, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(d, d_dif$Årskurs)
RIdifTableLR(d, d_dif$Årskurs)
```
:::

p och u har en residualkorrelation. u har sämre item-restscore.


## Analys 3 positiva items

```{r}
dpos_backup2 <- d

removed_items_pos <- c("f66l","f66u")

d <- d %>% 
  select(!any_of(removed_items_pos))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(d)
```

::: panel-tabset
### Mokken dimensionality
```{r}
aisp(d,lowerbound = 0.2) %>% 
  as.data.frame() %>% 
  set_names("h > 0.2") %>% 
  arrange(`h > 0.2`) %>% 
  kbl_rise(tbl_width = 20)
```

### Item-restscore
```{r}
d_test %>% 
  select(any_of(items.pos)) %>% 
  select(!any_of(removed_items_pos)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(d)
```
### Loadings 1st contrast
```{r}
RIloadLoc(d)
```
### Lokalt oberoende
```{r}
RIpartgamLD(d)
```
### Targeting
```{r}
#| fig-height: 4
d_test %>% 
  select(any_of(items.pos)) %>% 
  select(!any_of(removed_items_pos)) %>% 
  RItargeting()
```
### Itemhierarki
```{r}
#| fig-height: 4
RIitemHierarchy(d)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(items.pos)) %>% 
  select(!any_of(removed_items_pos)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,4))
```
### DIF kön
```{r}
RIpartgamDIF(d, d_dif$Kön)
RIdifTableLR(d, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(d, d_dif$Årskurs)
RIdifTableLR(d, d_dif$Årskurs)
```
### LRT
```{r}
RIbootLRT(d, iterations = 1500, cpu = 8)
```
### Item fit
```{r}
simfit <- RIgetfit(d, iterations = 250, cpu = 8)
RIitemfit(d, simfit)
```
:::

Väldigt små avvikelser från item fit.

```{r}
#| fig-height: 4
d_test %>% 
  select(any_of(items.pos)) %>% 
  select(!any_of(removed_items_pos)) %>% 
  RItif(samplePSI = T, cutoff = 3)
```

Inte utan problem, men inte heller helt illa. Dock är reliabiliteten lite låg.

```{r}
RIlistitems(d)
```

Oklart vad dessa items kan sägas mäta?

### Person fit positiva items

```{r}
RIpfit(d)
```


## Övriga items

```{r}
items.pos <- c("f66h","f66l","f66m","f66p","f66s","f66u")
items.neg <- c("f66a","f66c","f66d","f66g","f66o","f66q")

d_test2 <- d_test %>% 
  select(!all_of(items.pos)) %>% 
  select(!all_of(items.neg))

```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(d_test2)
```

::: panel-tabset
### Item-restscore
```{r}
d_test2 %>% 
  # select(all_of(kluster2)) %>% 
  # select(!any_of(removed_items2)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
#RIrestscore(d)
```
### LRT bootstrap
```{r}
d_test2 %>% 
  # select(all_of(kluster2)) %>% 
  # select(!any_of(removed_items2)) %>% 
  RIbootLRT()
```
### PCA of residuals
```{r}
RIpcmPCA(d_test2)
```
### Loadings 1st contrast
```{r}
RIloadLoc(d_test2)
```

### Lokalt oberoende
```{r}
RIpartgamLD(d_test2)
```
### Targeting
```{r}
#| fig-height: 5
d_test2 %>% 
  RItargeting()
```
:::

Loading-plotten får det att se ut som att items K E T bildar ett kluster, men det stämmer inte riktigt överens med item-restscore.

Item-restscore indikerar att k är underfit, och att b och n är overfit. I övrigt relativt små avvikelser.

Lokalt beroende: 

- Items E och T 
- B och N
- B och F

Vi gör som tidigare och tar bort B och E, men låter K vara kvar.

```{r}
removed_items3 <- c("f66b","f66e")

d_test2backup <- d_test2

d_test2 <- d_test2backup %>% 
  select(!any_of(removed_items3))
```

## Övriga items 2

```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(d_test2)
```

::: panel-tabset
### Item-restscore
```{r}
d_test2 %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
```
### LRT bootstrap
```{r}
d_test2 %>% 
  RIbootLRT()
```
### PCA of residuals
```{r}
RIpcmPCA(d_test2)
```
### Loadings 1st contrast
```{r}
RIloadLoc(d_test2)
```

### Lokalt oberoende
```{r}
RIpartgamLD(d_test2)
```
### Targeting
```{r}
#| fig-height: 5
d_test2 %>% 
  RItargeting()
```
### Itemhierarki
```{r}
#| fig-height: 5
d_test2 %>% 
  RIitemHierarchy()
```
### Score groups
```{r}
d_test2 %>% 
  slice_sample(n = 600) %>% 
  PCM() %>% 
  item_obsexp()
```
### DIF kön
```{r}
d_test2 %>% 
  RIpartgamDIF(d_testdif$Kön)

d_test2 %>% 
  RIdifTableLR(d_testdif$Kön)

d_test2 %>% 
  RIdifThreshFigLR(d_testdif$Kön)

```
### DIF årskurs
```{r}
d_test2 %>% 
  RIpartgamDIF(d_testdif$Årskurs)

d_test2 %>% 
  RIdifTableLR(d_testdif$Årskurs)

d_test2 %>% 
  RIdifThreshFigLR(d_testdif$Årskurs)

```
### DIF kön+årskurs
```{r}
RIdifTable2(d_test2, d_testdif$Kön, d_testdif$Årskurs)
```
### Reliability
```{r}
RItif(d_test2)
```
### Person fit
```{r}
RIpfit(d_test2)

RIpfit(d_test2, group = d_testdif$Kön)
```
:::

K är mindre underfit nu, men N är 100% overfit och har problem med lokalt beroende med F. Vi tar bort N.



## Övriga items 3

```{r}
removed_items3 <- c("f66b","f66e","f66n")

d_test2 <- d_test2backup %>% 
  select(!any_of(removed_items3))
```

```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(d_test2)
```

::: panel-tabset
### Item-restscore
```{r}
d_test2 %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
```
### LRT bootstrap
```{r}
d_test2 %>% 
  RIbootLRT()
```
### PCA of residuals
```{r}
RIpcmPCA(d_test2)
```
### Loadings 1st contrast
```{r}
RIloadLoc(d_test2)
```
### Lokalt oberoende
```{r}
RIpartgamLD(d_test2)
```
### Residualkorrelationer
```{r}
simcor <- RIgetResidCor(d_test2, iterations = 250, cpu = 8)
RIresidcorr(d_test2, cutoff = simcor$p99)
```
:::

I och R har en residualkorrelation över gränsvärdet. I är mest overfit och tas bort.


## Övriga items 4

```{r}
removed_items3 <- c("f66b","f66e","f66n","f66i")

d_test2 <- d_test2backup %>% 
  select(!any_of(removed_items3))
```

```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(d_test2)
```

::: panel-tabset
### Item-restscore
```{r}
d_test2 %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
```
### LRT bootstrap
```{r}
d_test2 %>% 
  RIbootLRT()
```
### PCA of residuals
```{r}
RIpcmPCA(d_test2)
```
### Loadings 1st contrast
```{r}
RIloadLoc(d_test2)
```

### Lokalt oberoende
```{r}
RIpartgamLD(d_test2)
```
### Targeting
```{r}
#| fig-height: 5
d_test2 %>% 
  RItargeting()
```
### Itemhierarki
```{r}
#| fig-height: 5
d_test2 %>% 
  RIitemHierarchy()
```
### Score groups
```{r}
d_test2 %>% 
  slice_sample(n = 600) %>% 
  PCM() %>% 
  item_obsexp()
```
### DIF kön
```{r}
d_test2 %>% 
  RIpartgamDIF(d_testdif$Kön)

d_test2 %>% 
  RIdifTableLR(d_testdif$Kön)

d_test2 %>% 
  RIdifThreshFigLR(d_testdif$Kön)

```
### DIF årskurs
```{r}
d_test2 %>% 
  RIpartgamDIF(d_testdif$Årskurs)

d_test2 %>% 
  RIdifTableLR(d_testdif$Årskurs)

d_test2 %>% 
  RIdifThreshFigLR(d_testdif$Årskurs)

```
### DIF kön+årskurs
```{r}
RIdifTable2(d_test2, d_testdif$Kön, d_testdif$Årskurs)
```
### Reliability
```{r}
#| fig-height: 4
RItif(d_test2, cutoff = 3, samplePSI = T)
RItif(d_test2[,-5], cutoff = 3, samplePSI = T)

```
### Person fit
```{r}
RIpfit(d_test2)

RIpfit(d_test2, group = d_testdif$Kön)
```
:::


"f66f" "f66j" "f66k" "f66r" "f66t" fungerar också ok.

```{r}
RIlistitems(d_test2)
```


## Sambandsanalyser

```{r}
kluster1 <- c("f66a","f66c","f66d","f66g","f66o","f66q")
kluster2 <- c("f66f", "f66j", "f66k" ,"f66r", "f66t")
kluster_pos <- c("f66h", "f66m", "f66p" ,"f66s")

d_theta <- d_test %>% 
  select(all_of(c(kluster1,kluster2,kluster_pos))) %>% 
  na.omit()

d_theta$k1theta <- d_theta %>% 
  select(all_of(kluster1)) %>% 
  RIestThetas() %>% 
  pull(WLE)

d_theta$k2theta <- d_theta %>% 
  select(all_of(kluster2)) %>% 
  RIestThetas() %>% 
  pull(WLE)

d_theta$k3theta <- d_theta %>% 
  select(all_of(kluster_pos)) %>% 
  RIestThetas() %>% 
  pull(WLE)

glimpse(d_theta)

library(correlation)
cor_test(data = d_theta, x = "k1theta", y = "k2theta") %>% plot() +
  labs(y = "Lättare negativa items", x = "Svårare negativa items")
cor_test(data = d_theta, x = "k1theta", y = "k3theta") %>% plot() +
  labs(y = "Positiva items", x = "Svårare negativa items")
cor_test(data = d_theta, x = "k2theta", y = "k3theta") %>% plot() +
  labs(y = "Positiva items", x = "Lättare negativa items")
```

Vi har här estimerat mätvärden på intervallskala utifrån items i de tre kluster som uppvisat acceptabla mätegenskaper. Kom ihåg att även det "positiva klustret" av items är kodat så att högre svar motsvarar högre problemnivå. Vi skulle annars förväntat oss en negativ korrelationskoefficient.

Korrelation mellan positiva klustret av items och det "lättare" negativa klustret av items är svag, r = .18, och något starkare mellan det "svårare" negativa klustret och det positiva, r = .33. Mellan de två negativa klustren är det klart starkare, r = .67.

### Samband med självrapporterad kriminalitet.

Vi kan jämföra den tidigare itemuppsättningen från de psykometriska analyserna 2022 med de två negativa klustren identifierade i denna analys. Med en maskininlärningsmetodik kan vi testa hur väl de olika item-uppsättningarna predicerar självrapporterade allvarligare brott.

Vi gör en utfallsvariabel som är binär, utifrån om man begått något av brotten utöver de tre vanligaste.


```{r}
items.brott <- df.all %>% 
  select(starts_with("f75")) %>% 
  names()

itemlabels_brott <- read_excel("itemlabels/BrottItemlabels.xls")

lowest3 <- c("f75p","f75i","f75a")
over3 <- items.brott[-c(1,9,17)]

df.ml <- df.all %>% 
  select(starts_with("f75"),starts_with("f66"),SkolSDO,ARSKURS,Kön,ar) %>% 
  select(!f66v_gammal) %>% 
  na.omit()

# ###### Individfaktorer
# # koda om svaren för items som ingår i individfaktorer, F66a-F66u i data, fråga 67 i PDF
# # variabler df[191:211]
# # hög poäng = hög risk
# # definiera svarskategorierna för att förenkla recode-koden
smd <- "Stämmer mycket dåligt"
sgd <- "Stämmer ganska dåligt"
sgb <- "Stämmer ganska bra"
smb <- "Stämmer mycket bra"

### New recode code below, using variable names instead of numbering

positiva.items <- c("f66h", "f66m", "f66p", "f66u") # create vector with reverse scored items
df.if <- df %>%
  slice(1:10) %>% 
  select(any_of(itemlabels$itemnr))
negativa.items <- df.if %>% # vector with items that are not reversed
  select(!any_of(positiva.items)) %>%
  names()

df.ml <- df.ml %>% 
  mutate(across(f66a:f66u, ~ as.numeric(.x))) %>% 
  mutate(across(all_of(negativa.items), ~ .x - 1),
         across(all_of(positiva.items), ~ car::recode(.x,"4=0;3=1;2=2;1=3"))) 

df.ml <- df.ml %>% 
  mutate(SkolSDO = factor(SkolSDO, levels = val_labels(df_recoded$SkolSDO),
                          labels = names(val_labels(df_recoded$SkolSDO)))) %>% 
  mutate(Årskurs = factor(ARSKURS, levels = val_labels(df_recoded$ARSKURS),
                          labels = names(val_labels(df_recoded$ARSKURS)))) %>% 
  select(!ARSKURS) %>% 
  mutate(SkolSDO = car::recode(SkolSDO,"99=NA;'Övrigt ospecificerat'=NA"),
         Årskurs = car::recode(Årskurs,"999=NA")) %>% 
  mutate(Kön = factor(Kön, levels = 1:2, labels = c("Pojke","Flicka")),
         År = as.numeric(ar)) %>% 
  select(!ar)

df.ml %>% 
  #count(f75d)
  select(all_of(over3)) %>% 
  gtsummary::tbl_summary()


df.brott <- df.ml %>% 
  rowwise() %>%
  mutate(begått = case_when(any(c_across(all_of(over3)) > 1) ~ 1,
                            
                              TRUE ~ 0))# %>% 
 # mutate(begått = factor(begått, levels = c(0,1),
 #                        labels = c("ej_brott","brott")))
df.brott %>% 
  group_by(Kön) %>% 
  count(begått) %>% 
  mutate(percent = 100*n/sum(n))

```

Prevalens bland pojkar är 28.8%, och flickor 20.5%.

```{r}
df.brott$k1theta <- df.brott %>% 
  select(all_of(kluster1)) %>% 
  RIestThetas() %>% 
  pull(WLE)

df.brott$k2theta <- df.brott %>% 
  select(all_of(kluster2)) %>% 
  RIestThetas() %>% 
  pull(WLE)

# gamla index med 9 items:
df.brott$k_old <- df.brott %>% 
  select(f66c,	f66d,	f66g,	f66j,	f66k,	f66n,	f66o,	f66q	,f66r) %>% 
  RIestThetas() %>% 
  pull(WLE)

# nytt "positivt index
df.brott$k3theta <- df.brott %>% 
  select(all_of(kluster_pos)) %>% 
  RIestThetas() %>% 
  pull(WLE)

df.brott$begått_f <- factor(df.brott$begått)
```

First, we use three separate logistic regression models and review the goodness-of-fit metrics

```{r}
m_old <- glm(begått_f ~ k_old + Kön, data = df.brott, family = binomial)
m_k1 <- glm(begått_f ~ k1theta + Kön, data = df.brott, family = binomial)
m_k2 <- glm(begått_f ~ k2theta + Kön, data = df.brott, family = binomial)
m_k12 <- glm(begått_f ~ k1theta + k2theta + Kön, data = df.brott, family = binomial)
m_k123 <- glm(begått_f ~ k1theta + k2theta + k3theta + Kön, data = df.brott, family = binomial)
#m_k123poisson <- glm(begått ~ k1theta + k2theta + k3theta + Kön, data = df.brott, family = poisson)


library(performance)
check_model(m_old)
check_model(m_k12)
check_model(m_k123)

library(modelsummary)
options(modelsummary_factory_default = 'kableExtra')
modelsummary(list("Old index (9 items)" = m_old,
                  "New index (6 items)" = m_k1,
                  "New alt. index (5 items)" = m_k2,
                  "Both new negative" = m_k12,
                  "All 3 new" = m_k123),
             vcov = "robust",exponentiate = T)

modelplot(list("Old index (9 items)" = m_old,
                  "New index (6 items)" = m_k1,
                  "New alt. index (5 items)" = m_k2),
             vcov = "robust", exponentiate = T)
anova(m_old,m_k1,m_k2)
```

Klara problem med residualer, så vi använder robusta standardfel.

Gamla indexet har bäst egenskaper när båda kön är med i analysen, med skillnaden är liten. Och det verkar tveksamt att använda 

Pojkar enbart:

```{r}
m_oldp <- glm(begått_f ~ k_old, data = df.brott %>% filter(Kön == "Pojke"), family = binomial)
m_k1p <- glm(begått_f ~ k1theta, data = df.brott %>% filter(Kön == "Pojke"), family = binomial)
m_k2p <- glm(begått_f ~ k2theta, data = df.brott %>% filter(Kön == "Pojke"), family = binomial)

modelsummary(list("Old index (9 items)" = m_oldp,
                  "New index (6 items)" = m_k1p,
                  "New alt. index (5 items)" = m_k2p))
```

Flickor enbart:

```{r}
m_oldf <- glm(begått_f ~ k_old, data = df.brott %>% filter(Kön == "Flicka"), family = binomial)
m_k1f <- glm(begått_f ~ k1theta, data = df.brott %>% filter(Kön == "Flicka"), family = binomial)
m_k2f <- glm(begått_f ~ k2theta, data = df.brott %>% filter(Kön == "Flicka"), family = binomial)

modelsummary(list("Old index (9 items)" = m_oldf,
                  "New index (6 items)" = m_k1f,
                  "New alt. index (5 items)" = m_k2f))
```

```{r}
library(tidymodels)
library(rsample)
set.seed(14578)

# Put 1/5 of the data into the training set 
data_split <- initial_split(df.brott, prop = 1/5, strata = År)

# Create data frames for the two sets:
d_train <- training(data_split)
d_testml  <- testing(data_split)

# old index
lr_mod <- 
  logistic_reg() %>% 
  set_engine("glm")

lr_recipe <- 
  recipe(begått_f ~ k_old, data = d_train) %>% 
  step_normalize(all_predictors())

lr_workflow <- 
  workflow() %>% 
  add_model(lr_mod) %>% 
  add_recipe(lr_recipe)

lr_fit <- lr_workflow %>% 
  last_fit(data_split)

metrics_old <- lr_fit %>% 
  collect_metrics()

# new index
lr_recipe <- 
  recipe(begått_f ~ k1theta, data = d_train) %>% 
  step_normalize(all_predictors())

lr_workflow <- 
  workflow() %>% 
  add_model(lr_mod) %>% 
  add_recipe(lr_recipe)

lr_fit <- lr_workflow %>% 
  last_fit(data_split)

metrics_k1 <- lr_fit %>% 
  collect_metrics()

# new index alt
lr_recipe <- 
  recipe(begått_f ~ k2theta, data = d_train) %>% 
  step_normalize(all_predictors())

lr_workflow <- 
  workflow() %>% 
  add_model(lr_mod) %>% 
  add_recipe(lr_recipe)

lr_fit <- lr_workflow %>% 
  last_fit(data_split)

metrics_k2 <- lr_fit %>% 
  collect_metrics()

# both new
lr_recipe <- 
  recipe(begått_f ~ k1theta + k2theta, data = d_train) %>% 
  step_normalize(all_predictors())

lr_workflow <- 
  workflow() %>% 
  add_model(lr_mod) %>% 
  add_recipe(lr_recipe)

lr_fit <- lr_workflow %>% 
  last_fit(data_split)

metrics_k12 <- lr_fit %>% 
  collect_metrics()

# 3 new
lr_recipe <- 
  recipe(begått_f ~ k1theta + k2theta + k3theta, data = d_train) %>% 
  step_normalize(all_predictors())

lr_workflow <- 
  workflow() %>% 
  add_model(lr_mod) %>% 
  add_recipe(lr_recipe)

lr_fit <- lr_workflow %>% 
  last_fit(data_split)

metrics_k123 <- lr_fit %>% 
  collect_metrics()

metrics_old
metrics_k1
metrics_k2
metrics_k12
metrics_k123
# library(vip)  
# lr_fit %>% 
#   extract_fit_parsnip() %>% 
#   vip(num_features = 20)
```

Även här ser det ut som att gamla indexet är marginellt bättre, men att de två nya indexen tillsammans är lite lite bättre än gamla indexet. Det nya positiva tillför inget.

Jämföra items i gamla och nya:

```{r}
itemlabels %>% 
  filter(itemnr %in% c("f66c",	"f66d",	"f66g",	"f66j",	"f66k",	"f66n",	"f66o",	"f66q"	,"f66r"))

itemlabels %>% 
  filter(itemnr %in% kluster1)
```

cdgoq är med i båda, a enbart i nya, och jknr i det gamla. Alla jknr-items är "spänningssökande", och jkr (ej n) ingår i nya kluster 2.

```{r}
itemlabels %>% 
  filter(itemnr %in% kluster2)
```

## 2022 index

Ingen genomgående analysprocess, bara ett test för att kunna jämföra.

```{r}
oldi <- c("f66c",	"f66d",	"f66g",	"f66j",	"f66k",	"f66n",	"f66o",	"f66q"	,"f66r")
```

```{r}
#| column: margin
#| echo: false

d_test %>% 
  select(all_of(oldi)) %>% 
  RIlistItemsMargin()
```

::: panel-tabset
### Item-restscore
```{r}
d_test %>% 
  select(all_of(oldi)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
```
### LRT bootstrap
```{r}
d_test %>% 
  select(all_of(oldi)) %>% 
  RIbootLRT()
```
### PCA of residuals
```{r}
d_test %>% 
  select(all_of(oldi)) %>% 
  RIpcmPCA()
```
### Loadings 1st contrast
```{r}
d_test %>% 
  select(all_of(oldi)) %>% 
  RIloadLoc()
```
### Lokalt oberoende
```{r}
d_test %>% 
  select(all_of(oldi)) %>% 
  RIpartgamLD()
```
### Residualkorrelationer
```{r}
simcor <- d_test %>% 
  select(all_of(oldi)) %>% 
  RIgetResidCor(iterations = 250, cpu = 8)

d_test %>% 
  select(all_of(oldi)) %>% 
  RIresidcorr(cutoff = simcor$p99)
```
:::


## Analys av delskalor {#sec-ifDelskalor}

De 21 frågor som ingår under rubriken "Individfaktorer" har delats in i sju delskalor med tre items vardera.

- Trotsighet (f66a,f66g,f66o)
- Spänningssökande - (f66b,f66j,f66n)
- Aggressivitet - (f66c,f66e,f66t)
- Antisocialt beteende - (f66d,f66f,f66k)
- Problemlösning - (f66h,f66l,f66s)
- Impulsivitet - (f66i,f66m,f66r)
- Moral - (f66p,f66q,f66u)

```{r}
# create vectors with items for each subscale
Trotsighet <- as.character(expression(f66a,f66g,f66o))
Spänningssökande <- as.character(expression(f66b,f66j,f66n))
Aggressivitet <- as.character(expression(f66c,f66e,f66t))
Antisocialt <- as.character(expression(f66d,f66f,f66k))
Problemlösning <- as.character(expression(f66h,f66l,f66s))
Impulsivitet <- as.character(expression(f66i,f66m,f66r))
Moral <- as.character(expression(f66p,f66q,f66u))
```

## Trotsighet

```{r}
# subset items to dataframe
subskala <- Trotsighet

df.subskala <- d_backup %>% 
  select(all_of(subskala))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(df.subskala)
```

::: panel-tabset
### Item-restscore
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(df.subskala)
```
### Lokalt oberoende
```{r}
RIpartgamLD(df.subskala)
simcor <- RIgetResidCor(df.subskala, iterations = 250, cpu = 8)
RIresidcorr(df.subskala, cutoff = simcor$p99)
```
### Targeting
```{r}
#| fig-height: 4
RItargeting(df.subskala)
```
### Itemhierarki
```{r}
#| fig-height: 4
RIitemHierarchy(df.subskala)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,6))
```
### DIF kön
```{r}
RIpartgamDIF(df.subskala, d_dif$Kön)
RIdifTableLR(df.subskala, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(df.subskala, d_dif$Årskurs)
RIdifTableLR(df.subskala, d_dif$Årskurs)
```
### LRT
```{r}
clr_tests(df.subskala, model = "PCM")
RIbootLRT(df.subskala)
```
### Reliabilitet
```{r}
#| fig-height: 4

RItif(df.subskala, samplePSI = T)
```
:::


## Spänningssökande
```{r}
# subset items to dataframe
subskala <- Spänningssökande

df.subskala <- d_backup %>% 
  select(all_of(subskala))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(df.subskala)
```

::: panel-tabset
### Item-restscore
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(df.subskala)
```
### Lokalt oberoende
```{r}
RIpartgamLD(df.subskala)
simcor <- RIgetResidCor(df.subskala, iterations = 250, cpu = 8)
RIresidcorr(df.subskala, cutoff = simcor$p99)
```
### Targeting
```{r}
#| fig-height: 4
RItargeting(df.subskala)
```
### Itemhierarki
```{r}
#| fig-height: 4
RIitemHierarchy(df.subskala)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,6))
```
### DIF kön
```{r}
RIpartgamDIF(df.subskala, d_dif$Kön)
RIdifTableLR(df.subskala, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(df.subskala, d_dif$Årskurs)
RIdifTableLR(df.subskala, d_dif$Årskurs)
```
### LRT
```{r}
clr_tests(df.subskala, model = "PCM")
RIbootLRT(df.subskala)
```
### Reliabilitet
```{r}
#| fig-height: 4

RItif(df.subskala, samplePSI = T)
```
:::

## Aggressivitet
```{r}
# subset items to dataframe
subskala <- Aggressivitet

df.subskala <- d_backup %>% 
  select(all_of(subskala))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(df.subskala)
```

::: panel-tabset
### Item-restscore
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(df.subskala)
```
### Lokalt oberoende
```{r}
RIpartgamLD(df.subskala)
simcor <- RIgetResidCor(df.subskala, iterations = 250, cpu = 8)
RIresidcorr(df.subskala, cutoff = simcor$p99)
```
### Targeting
```{r}
#| fig-height: 4
RItargeting(df.subskala)
```
### Itemhierarki
```{r}
#| fig-height: 4
RIitemHierarchy(df.subskala)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,6))
```
### DIF kön
```{r}
RIpartgamDIF(df.subskala, d_dif$Kön)
RIdifTableLR(df.subskala, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(df.subskala, d_dif$Årskurs)
RIdifTableLR(df.subskala, d_dif$Årskurs)
```
### LRT
```{r}
clr_tests(df.subskala, model = "PCM")
RIbootLRT(df.subskala)
```
### Reliabilitet
```{r}
#| fig-height: 4

RItif(df.subskala, samplePSI = T)
```
:::


## Antisocialt beteende
```{r}
# subset items to dataframe
subskala <- Antisocialt

df.subskala <- d_backup %>% 
  select(all_of(subskala))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(df.subskala)
```

::: panel-tabset
### Item-restscore
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(df.subskala)
```
### Lokalt oberoende
```{r}
RIpartgamLD(df.subskala)
simcor <- RIgetResidCor(df.subskala, iterations = 250, cpu = 8)
RIresidcorr(df.subskala, cutoff = simcor$p99)
```
### Targeting
```{r}
#| fig-height: 4
RItargeting(df.subskala)
```
### Itemhierarki
```{r}
#| fig-height: 4
RIitemHierarchy(df.subskala)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,6))
```
### DIF kön
```{r}
RIpartgamDIF(df.subskala, d_dif$Kön)
RIdifTableLR(df.subskala, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(df.subskala, d_dif$Årskurs)
RIdifTableLR(df.subskala, d_dif$Årskurs)
```
### LRT
```{r}
clr_tests(df.subskala, model = "PCM")
RIbootLRT(df.subskala)
```
### Reliabilitet
```{r}
#| fig-height: 4

RItif(df.subskala, samplePSI = T)
```
:::


## Problemlösning

```{r}
# subset items to dataframe
subskala <- Problemlösning

df.subskala <- d_backup %>% 
  select(all_of(subskala))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(df.subskala)
```

::: panel-tabset
### Item-restscore
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(df.subskala)
```
### Lokalt oberoende
```{r}
RIpartgamLD(df.subskala)
simcor <- RIgetResidCor(df.subskala, iterations = 250, cpu = 8)
RIresidcorr(df.subskala, cutoff = simcor$p99)
```
### Targeting
```{r}
#| fig-height: 4
RItargeting(df.subskala)
```
### Itemhierarki
```{r}
#| fig-height: 4
RIitemHierarchy(df.subskala)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,6))
```
### DIF kön
```{r}
RIpartgamDIF(df.subskala, d_dif$Kön)
RIdifTableLR(df.subskala, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(df.subskala, d_dif$Årskurs)
RIdifTableLR(df.subskala, d_dif$Årskurs)
```
### LRT
```{r}
clr_tests(df.subskala, model = "PCM")
RIbootLRT(df.subskala)
```
### Reliabilitet
```{r}
#| fig-height: 4

RItif(df.subskala, samplePSI = T)
```
:::


## Impulsivitet
```{r}
# subset items to dataframe
subskala <- Impulsivitet

df.subskala <- d_backup %>% 
  select(all_of(subskala))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(df.subskala)
```

::: panel-tabset
### Item-restscore
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(df.subskala)
```
### Lokalt oberoende
```{r}
RIpartgamLD(df.subskala)
simcor <- RIgetResidCor(df.subskala, iterations = 250, cpu = 8)
RIresidcorr(df.subskala, cutoff = simcor$p99)
```
### Targeting
```{r}
#| fig-height: 4
RItargeting(df.subskala)
```
### Itemhierarki
```{r}
#| fig-height: 4
RIitemHierarchy(df.subskala)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,6))
```
### DIF kön
```{r}
RIpartgamDIF(df.subskala, d_dif$Kön)
RIdifTableLR(df.subskala, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(df.subskala, d_dif$Årskurs)
RIdifTableLR(df.subskala, d_dif$Årskurs)
```
### LRT
```{r}
clr_tests(df.subskala, model = "PCM")
RIbootLRT(df.subskala)
```
### Reliabilitet
```{r}
#| fig-height: 4

RItif(df.subskala, samplePSI = T)
```
:::


## Moral
```{r}
# subset items to dataframe
subskala <- Moral

df.subskala <- d_backup %>% 
  select(all_of(subskala))
```


```{r}
#| column: margin
#| echo: false
RIlistItemsMargin(df.subskala)
```

::: panel-tabset
### Item-restscore
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  RIbootRestscore(iterations = 200, samplesize = 600, cpu = 8)
RIrestscore(df.subskala)
```
### Lokalt oberoende
```{r}
RIpartgamLD(df.subskala)
simcor <- RIgetResidCor(df.subskala, iterations = 250, cpu = 8)
RIresidcorr(df.subskala, cutoff = simcor$p99)
```
### Targeting
```{r}
#| fig-height: 4
RItargeting(df.subskala)
```
### Itemhierarki
```{r}
#| fig-height: 4
RIitemHierarchy(df.subskala)
```
### Svarskategorier
```{r}
d_test %>% 
  select(any_of(subskala)) %>% 
  mirt(model=1, itemtype='Rasch', verbose = FALSE) %>% 
  plot(type="trace", as.table = TRUE, 
       theta_lim = c(-4,6))
```
### DIF kön
```{r}
RIpartgamDIF(df.subskala, d_dif$Kön)
RIdifTableLR(df.subskala, d_dif$Kön)
```
### DIF årskurs
```{r}
RIpartgamDIF(df.subskala, d_dif$Årskurs)
RIdifTableLR(df.subskala, d_dif$Årskurs)
```
### LRT
```{r}
clr_tests(df.subskala, model = "PCM")
RIbootLRT(df.subskala)
```
### Reliabilitet
```{r}
#| fig-height: 4

RItif(df.subskala, samplePSI = T)
```
:::


## Delskalor - sammanfattande kommentar

Genomgående låg reliabilitet, vilket är förväntat med endast tre frågor med fyra svarskategorier vardera. Flera delskalor har problem med att ett item inte passar in, vilket ibland framgår genom att det finns ett lokalt beroende mellan de två andra items. 


## Programvara som använts

```{r}
#| label: packagesv
sessionInfo()
```

